1.
Memoization is a way of optimizing a search algorithm by storing previously found results for future use. 
2. 
Is the code
3.
The code calculates the Fibonacci sequence up to a specified number. For example an input of 5 would give the fifth fibonacci number (which also happens to be 5).
4.
No, as a divide-and-conquer algorithm depends on a set of data. The only input is a single integer that produces a certain number.
5.
The time complexity of the given code is 
6.
See ex1.3.py file
7.
The computational complexity of the updated function would be O(lg(n)) . Following the rules to calculate complexity, A) the longest path would be taken, so the path through the else statement where there would be no early return statements, B) the lowest order terms are discarded, so any single operations are not taken into account, and C) multiplicative constants are not to be taken into account which involve in the section of code involving two recursive function calls. Taking all of that into account, the complexity would O(lg(n)) as the implementation of memoization cuts down on a lot of time needed as it does not need to calculate the same integers over and over again. 
8.
Code and plotting shown in ex1.5.py file
9.
The plot for the original code is as expected, which is O(n^2) and is easily seen. The plot for the changed function is much more consistent which is to be expected with the implementation of memoization for the function, and as a result it tracks with the computational complexity of O(lg(n))